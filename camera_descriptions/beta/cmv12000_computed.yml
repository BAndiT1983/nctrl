analog_gain:
  description: The analog gain of the image Sensor. Can be < 1 due to the sensors ability to divitde the signal
  type: float
  get: return cooked.pga_gain / cooked.pga_div
  set: |
    -- brute force all possible combinations, to get the closest
    local final_gain = -1
    local best_delta = 100 -- some large value
    local final_div = -1

    for gain=1,4 do
      for _, div in ipairs({1, 3}) do
        delta = math.abs((gain/div) - value)
        if delta < best_delta then
          final_gain = gain
          final_div = div
          best_delta = delta
        end
      end
    end

    cooked.pga_gain = final_gain
    cooked.pga_div = final_div

exposure_time_raw:
  description: raw register setting of the exposure time
  type: int
  get: |
    return raw.exp_time_low | (raw.exp_time_high << 16)
  set: |
    raw.exp_time_low = value & 0xFFFF
    raw.exp_time_high = value >> 16


fot_overlap:
  description: ""
  type: int
  get: |
    return 34 * (raw.fot_timing & 0xFF) + 1;

exposure_time:
  description: > 
    The exposure time in nano seconds.
    If the sensor is in interleaved HDR mode this applies to the even rows.
  type: float
  get: |
    -- formula from the datasheet p38

    val = computed.exposure_time_raw
    time_in_pixels = (val - 1) * (raw.slot_timing + 1) + computed.fot_overlap

    return time_in_pixels * (pixel_bits / lvds_clk) * 1e9;
  set: |
    -- stolen code from https://github.com/apertus-open-source-cinema/axiom-beta-firmware/blob/master/software/sensor_tools/snap/snap.c#L415

    pixels = value * 1e-9 * (lvds_clk / pixel_bits) -- number of pixels for one exposure
    val = 1
    if tonumber(computed.fot_overlap) < pixels then
      val = (pixels - computed.fot_overlap) / (raw.slot_timing + 1) + 1;
    end

    computed.exposure_time_raw = math.floor(val)

exposure_time_s:
  description: >
    The exposure time in seconds.
    If the sensor is in interleaved HDR mode this applies to the even rows.
  type: float
  get: return computed.exposure_time / 1e9
  set: computed.exposure_time = value * 1e9

temperature_celsius:
  description: > 
    The sensor temperature in degrees celsius.
    Could be completely off un uncalibrated state
  type: float
  get: |
    temperature_sensor_clock = (lvds_clk / pixel_bits)
    offset_dn = (825 * temperature_sensor_clock) / 30
    slope = (3.5 * temperature_sensor_clock) / 30
    return (offset_dn + raw.temp_sensor) / slope
